<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/nisaacson/pdf-extract#readme"

    >pdf-extract (v1.0.11)</a>
</h1>
<h4>Node PDF is a set of tools that takes in PDF files and converts them to usable formats for data processing. The library supports both extracting text from searchable pdf files as well as performing OCR on pdfs which are just scanned images of text</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.pdf-extract">module pdf-extract</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdf-extract.electronic">
            function <span class="apidocSignatureSpan">pdf-extract.</span>electronic
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdf-extract.raw">
            function <span class="apidocSignatureSpan">pdf-extract.</span>raw
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pdf-extract.</span>electronic.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pdf-extract.</span>raw.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pdf-extract.electronic">module pdf-extract.electronic</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdf-extract.electronic.electronic">
            function <span class="apidocSignatureSpan">pdf-extract.</span>electronic
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdf-extract.electronic.super_">
            function <span class="apidocSignatureSpan">pdf-extract.electronic.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pdf-extract.electronic.prototype">module pdf-extract.electronic.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdf-extract.electronic.prototype.process">
            function <span class="apidocSignatureSpan">pdf-extract.electronic.prototype.</span>process
            <span class="apidocSignatureSpan">(pdf_path, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pdf-extract.raw">module pdf-extract.raw</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdf-extract.raw.raw">
            function <span class="apidocSignatureSpan">pdf-extract.</span>raw
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdf-extract.raw.super_">
            function <span class="apidocSignatureSpan">pdf-extract.raw.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pdf-extract.raw.prototype">module pdf-extract.raw.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pdf-extract.raw.prototype.process">
            function <span class="apidocSignatureSpan">pdf-extract.raw.prototype.</span>process
            <span class="apidocSignatureSpan">(pdf_path, options)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pdf-extract" id="apidoc.module.pdf-extract">module pdf-extract</a></h1>


    <h2>
        <a href="#apidoc.element.pdf-extract.electronic" id="apidoc.element.pdf-extract.electronic">
        function <span class="apidocSignatureSpan">pdf-extract.</span>electronic
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Electronic(){
  if(false === (this instanceof Electronic)) {
    return new Electronic();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdf-extract.raw" id="apidoc.element.pdf-extract.raw">
        function <span class="apidocSignatureSpan">pdf-extract.</span>raw
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Raw(){
  if(false === (this instanceof Raw)) {
    return new Raw();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pdf-extract.electronic" id="apidoc.module.pdf-extract.electronic">module pdf-extract.electronic</a></h1>


    <h2>
        <a href="#apidoc.element.pdf-extract.electronic.electronic" id="apidoc.element.pdf-extract.electronic.electronic">
        function <span class="apidocSignatureSpan">pdf-extract.</span>electronic
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Electronic(){
  if(false === (this instanceof Electronic)) {
    return new Electronic();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdf-extract.electronic.super_" id="apidoc.element.pdf-extract.electronic.super_">
        function <span class="apidocSignatureSpan">pdf-extract.electronic.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pdf-extract.electronic.prototype" id="apidoc.module.pdf-extract.electronic.prototype">module pdf-extract.electronic.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pdf-extract.electronic.prototype.process" id="apidoc.element.pdf-extract.electronic.prototype.process">
        function <span class="apidocSignatureSpan">pdf-extract.electronic.prototype.</span>process
        <span class="apidocSignatureSpan">(pdf_path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process = function (pdf_path, options) {
  var self = this;
  var text_pages = [];
  var split_output;
  var single_page_pdf_file_paths = [];
  fs.exists(pdf_path, function (exists) {
    var err;
    if (!exists) {
      err = &#x27;no file exists at the path you specified: &#x27; + pdf_path
      self.emit(&#x27;error&#x27;, { error: err, pdf_path: pdf_path});
      return
    }
    pathhash(pdf_path, function (err, hash) {
      if (err) {
        err = &#x27;error hashing file at the path you specified: &#x27; + pdf_path + &#x27;. &#x27; + err;
        self.emit(&#x27;error&#x27;, { error: err, pdf_path: pdf_path});
        return
      }
      // split the pdf into single page pdf files
      split(pdf_path, function (err, output) {
        if (err) {
          self.emit(&#x27;error&#x27;, { error: err, pdf_path: pdf_path});
          return
        }


        if (!output) {
          err = &#x27;failed to split pdf file into distinct pages&#x27;;
          self.emit(&#x27;error&#x27;, { error: err, pdf_path: pdf_path});
          return
        }
        split_output = output;
        if (!split_output.hasOwnProperty(&#x27;files&#x27;) || split_output.files.length == 0) {
          err = &#x27;no pages where found in your pdf document&#x27;;
          self.emit(&#x27;error&#x27;, { error: err, pdf_path: pdf_path});
          return
        }
        self.emit(&#x27;log&#x27;, &#x27;finished splitting pages for file at path &#x27; + pdf_path);
        var files = split_output.files;
        var index = 0;
        async.forEachSeries(
          files,
          // extract the text for each page
          function (file, cb) {
            index++;
            searchable(file.file_path, options, function (err, extract) {
	          if(err){
	            self.emit(&#x27;error&#x27;, { error: err, pdf_path: pdf_path});
	            return;
	          }
              text_pages.push(extract);
              var file_path = file.file_path
              single_page_pdf_file_paths.push(file.file_path);
              self.emit(&#x27;page&#x27;, { hash: hash, text: extract, index: index, pdf_path: pdf_path});
              cb();
            });
          },
          function (err) {
            if (!err) {
              self.emit(&#x27;complete&#x27;, { hash: hash, text_pages: text_pages, pdf_path: pdf_path, single_page_pdf_file_paths: single_page_pdf_file_paths
});
              return;
            }
            self.emit(&#x27;error&#x27;, { error: err, pdf_path: pdf_path});
            if (!split_output || ! split_output.folder) { return }
            fs.exists(split_output.folder, function (exists) {
              if (!exists) { return }
              var remove_cb = function() {}
              rimraf(split_output.folder, remove_cb);
            });
          }
        );
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return cb(err);;
  }
  fs.exists(pdf_path, function (exists) {
    if (!exists) {
      err = &#x27;no file exists at the path you specified&#x27;;
      return cb(err);
    }
    processor.<span class="apidocCodeKeywordSpan">process</span>(pdf_path, options);
    cb();
  });
  return processor;
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pdf-extract.raw" id="apidoc.module.pdf-extract.raw">module pdf-extract.raw</a></h1>


    <h2>
        <a href="#apidoc.element.pdf-extract.raw.raw" id="apidoc.element.pdf-extract.raw.raw">
        function <span class="apidocSignatureSpan">pdf-extract.</span>raw
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Raw(){
  if(false === (this instanceof Raw)) {
    return new Raw();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pdf-extract.raw.super_" id="apidoc.element.pdf-extract.raw.super_">
        function <span class="apidocSignatureSpan">pdf-extract.raw.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pdf-extract.raw.prototype" id="apidoc.module.pdf-extract.raw.prototype">module pdf-extract.raw.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pdf-extract.raw.prototype.process" id="apidoc.element.pdf-extract.raw.prototype.process">
        function <span class="apidocSignatureSpan">pdf-extract.raw.prototype.</span>process
        <span class="apidocSignatureSpan">(pdf_path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process = function (pdf_path, options) {
  var self = this;
  var text_pages = [];
  var split_output;
  if (!options) {
    options = {};
  }
  // default to removing the single page pdfs after ocr completes
  if (!options.hasOwnProperty(&#x27;clean&#x27;)) {
    options.clean = true;
  }
  fs.exists(pdf_path, function (exists) {
    if (!exists) {
      var err = &#x27;no file exists at the path you specified: &#x27; + pdf_path
      self.emit(&#x27;error&#x27;, { error: err, pdf_path: pdf_path});
      return
    }
    pathHash(pdf_path, function (err, hash) {
      if (err) {
        err = &#x27;error hashing file at the path you specified: &#x27; + pdf_path + &#x27;. &#x27; + err;
        self.emit(&#x27;error&#x27;, { error: err, pdf_path: pdf_path});
        return;
      }
      split(pdf_path, function (err, output) {
        if (err) {
          self.emit(&#x27;error&#x27;, { error: err, pdf_path: pdf_path});
          return
        }
        if (!output) {
          err = &#x27;no files returned from split&#x27;;
          self.emit(&#x27;error&#x27;, { error: err, pdf_path: pdf_path});
          return;
        }
        self.emit(&#x27;log&#x27;, &#x27;finished splitting pages for file at path &#x27; + pdf_path);
        split_output = output;
        var pdf_files = output.files;
        if (!pdf_files || pdf_files.length == 0) {
          err = &#x27;error, no pages where found in your pdf document&#x27;;
          self.emit(&#x27;error&#x27;, { error: err, pdf_path: pdf_path});
          return;
        }
        var index = 0;
        var num_pages = pdf_files.length
        var single_page_pdf_file_paths = [];
        async.forEachSeries(
          pdf_files,
          // extract the text for each page via ocr
          function (pdf_file, cb) {
            var quality = 300;
            if (options.hasOwnProperty(&#x27;quality&#x27;) &#x26;&#x26; options.quality) {
              quality = options.quality;
            }
            convert(pdf_file.file_path, quality, function (err, tif_path) {
              var zeroBasedNumPages = num_pages-1;
              self.emit(&#x27;log&#x27;, &#x27;converted page to intermediate tiff file, page &#x27;+ index+ &#x27; (0-based indexing) of &#x27;+ zeroBasedNumPages
);
              if (err) { return cb(err); }
              var ocr_flags = [
                &#x27;-psm 6&#x27;
              ];
              if (options.ocr_flags) {
                ocr_flags = options.ocr_flags;
              }
              ocr(tif_path, ocr_flags, function (err, extract) {
                fs.unlink(tif_path, function (tif_cleanup_err, reply) {
                  if (tif_cleanup_err) {
                    err += &#x27;, error removing temporary tif file: &#x22;&#x27;+tif_cleanup_err+&#x27;&#x22;&#x27;;
                  }
                  if (err) { return cb(err); }
                  var page_number = index+1
                  self.emit(&#x27;log&#x27;, &#x27;raw ocr: page &#x27; + index + &#x27; (0-based indexing) of &#x27; +zeroBasedNumPages + &#x27; complete&#x27;);
                  single_page_pdf_file_paths.push(pdf_file.file_path);
                  self.emit(&#x27;page&#x27;, { hash: hash, text: extract, index: index, num_pages: num_pages, pdf_path: pdf_path, single_page_pdf_path
: pdf_file.file_path});
                  text_pages.push(extract);
                  index++;
                  cb();
                });
              });
            });
          }, function (err) {
            if (err) {
              self.emit(&#x27;error&#x27;, err);
              return;
            }
            self.emit(&#x27;complete&#x27;, { hash: hash, text_pages: text_pages, pdf_path: pdf_path, single_page_pdf_file_paths: single_page_pdf_file_paths
});
          });
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return cb(err);;
  }
  fs.exists(pdf_path, function (exists) {
    if (!exists) {
      err = &#x27;no file exists at the path you specified&#x27;;
      return cb(err);
    }
    processor.<span class="apidocCodeKeywordSpan">process</span>(pdf_path, options);
    cb();
  });
  return processor;
}
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
